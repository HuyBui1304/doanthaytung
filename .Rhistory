<<<<<<< HEAD
df <- read.csv('healthcare-dataset-stroke-data.csv')
head(df)
str(df)
df$gender <- as.factor(df$gender)
df$ever_married <- as.factor(df$ever_married)
df$work_type <- as.factor(df$work_type)
df$Residence_type <- as.factor(df$Residence_type)
df$smoking_status <- as.factor(df$smoking_status)
df$bmi <- as.numeric(df$bmi)
df <- subset(df, select = -id)
df$bmi <- as.numeric(df$bmi)
df <- subset(df, select = -id)
str(df)
missing_values <- colSums(is.na(df))
print(missing_values)
df$gender <- as.numeric(as.factor(df$gender))
df$ever_married <- as.numeric(as.factor(df$ever_married))
df$work_type <- as.numeric(as.factor(df$work_type))
df$Residence_type <- as.numeric(as.factor(df$Residence_type))
df$smoking_status <- as.numeric(as.factor(df$smoking_status))
# Tạo ma trận tương quan, tránh mất dữ liệu
cor_matrix <- cor(df[, sapply(df, is.numeric)], use = "pairwise.complete.obs")
# Vẽ heatmap tương quan
corrplot(cor_matrix, method = "color", col = colorRampPalette(c("blue", "white", "red"))(200),
tl.cex = 0.8, tl.col = "black", number.cex = 0.7, addCoef.col = "black")
install.packages("corrplot")
library(corrplot)
install.packages("rpart")
library(rpart)
df <- read.csv('healthcare-dataset-stroke-data.csv')
library(rpart)
# Vẽ heatmap tương quan
corrplot(cor_matrix, method = "color", col = colorRampPalette(c("blue", "white", "red"))(200),
tl.cex = 0.8, tl.col = "black", number.cex = 0.7, addCoef.col = "black")
cor_with_bmi <- cor_matrix["bmi", ]
cor_with_bmi <- sort(cor_with_bmi, decreasing = TRUE)
print(cor_with_bmi)
important_features <- names(cor_with_bmi[cor_with_bmi > 0.2])
important_features <- setdiff(important_features, "bmi")
print(important_features)
train_data <- df[!is.na(df$bmi), c(important_features, "bmi")]
missing_data <- df[is.na(df$bmi), important_features]
bmi_model <- rpart(bmi ~ ., data = train_data, method = "anova")
df$bmi[is.na(df$bmi)] <- predict(bmi_model, newdata = missing_data)
print(sum(is.na(df)))
str(df)
df$gender <- factor(df$gender, levels = c(1, 2, 3), labels = c("Female", "Male", "Other"))
df$ever_married <- factor(df$ever_married, levels = c(1, 2), labels = c("No", "Yes"))
df$work_type <- factor(df$work_type, levels = c(1, 2, 3, 4, 5),
labels = c("children", "Govt_job", "Never_worked", "Private", "Self-employed"))
df$Residence_type <- factor(df$Residence_type, levels = c(1, 2), labels = c("Rural", "Urban"))
df$smoking_status <- factor(df$smoking_status, levels = c(1, 2, 3, 4),
labels = c("formerly smoked", "never smoked", "smokes", "Unknown"))
str(df)
# Lấy danh sách các biến số (numeric) trong dataframe
numeric_vars <- names(df)[sapply(df, is.numeric)]
# Thiết lập bố cục để vẽ tất cả boxplot trên một hàng
par(mfrow = c(1, length(numeric_vars)))
# Lặp qua từng biến số và vẽ boxplot theo chiều dọc
for (var in numeric_vars) {
boxplot(df[[var]], main = paste("Boxplot of", var),
col = "lightblue")
}
# Lặp qua từng biến số và vẽ boxplot theo chiều dọc
for (var in numeric_vars) {
boxplot(df[[var]], main = paste("Boxplot of", var),
col = "lightblue")
}
# Đặt lại bố cục mặc định
par(mfrow = c(1,1))
# Xác định các biến số (numeric)
numeric_vars <- names(df)[sapply(df, is.numeric)]
# Kiểm tra outliers bằng IQR và in kết quả
for (var in numeric_vars) {
=======
boxplot(df$avg_glucose_level, main = " Boxplot of Avg Glucose Level", col = "skyblue", border = "black")
boxplot(df$bmi, main = " boxplot of BMI", col = "skyblue", border = "black")
vars_to_check <- c("age", "avg_glucose_level", "bmi")
# Kiểm tra outliers và in kết quả
vars_to_check <- c("age", "avg_glucose_level", "bmi")
for (var in vars_to_check) {
>>>>>>> 15b26c7d1d941b34c356f44a659f4e5911bcd13b
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
num_outliers <- sum(df[[var]] < lower_bound | df[[var]] > upper_bound, na.rm = TRUE)
cat("Biến:", var, "- Tổng số outliers:", num_outliers, "\n")
}
<<<<<<< HEAD
# Vẽ boxplot theo chiều dọc, tất cả trên một hàng
par(mfrow = c(1, length(numeric_vars)))
for (var in numeric_vars) {
boxplot(df[[var]], main = paste("Boxplot of", var),
col = "pink")  # Mặc định vẽ dọc
}
# Vẽ boxplot theo chiều dọc, tất cả trên một hàng
par(mfrow = c(1, length(numeric_vars)))
for (var in numeric_vars) {
boxplot(df[[var]], main = paste("Boxplot of", var),
col = "pink")  # Mặc định vẽ dọc
}
par(mfrow = c(1,1))
# Vẽ boxplot theo chiều dọc, tất cả trên một hàng
par(mfrow = c(1, length(numeric_vars)))
for (var in numeric_vars) {
boxplot(df[[var]], main = paste("Boxplot of", var),
col = "pink")  # Mặc định vẽ dọc
}
=======
total_rows <- nrow(df)
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
num_outliers <- sum(df[[var]] < lower_bound | df[[var]] > upper_bound, na.rm = TRUE)
percent_outliers <- (num_outliers / total_rows) * 100  # Tính phần trăm outliers
cat("Biến:", var, "- Tổng số outliers:", num_outliers,
"- Phần trăm outliers:", round(percent_outliers, 2), "%\n")
}
# In ra danh sách outliers cho từng biến
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
outliers <- df[[var]][df[[var]] < lower_bound | df[[var]] > upper_bound]
cat("\nBiến:", var, "- Tổng số outliers:", length(outliers), "\n")
print(outliers)
}
# thay thế outliers
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
df[[var]][df[[var]] < lower_bound] <- lower_bound
df[[var]][df[[var]] > upper_bound] <- upper_bound
}
# kiểm tra lại
par(mfrow = c(1,3))
boxplot(df$age, main = "Boxplot of Age (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$avg_glucose_level, main = "Boxplot of Avg Glucose Level (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$bmi, main = "Boxplot of BMI (After Winsorization)", col = "skyblue", border = "black")
par(mfrow = c(1,1))
# vẽ biểu đồ hist xem sự phân bố dữ liệu
# Lấy danh sách các biến số (numeric) trong dataframe
numeric_vars <- names(df)[sapply(df, is.numeric)]
par(mfrow = c(ceiling(length(numeric_vars)/3),3))
for (var in numeric_vars){
hist(df[[var]], main = paste("histogram of", var), xlab = var, col = "green",
border = "black", breaks = 20)}
par(mfrow = c(1, 1))
categorical_vars <- names(df)[sapply(df, is.factor)]
par(mfrow = c(ceiling(length(categorical_vars) / 3), 3))
for (var in categorical_vars) {
barplot(table(df[[var]]), main = paste("Barplot of", var), col = rainbow(length(unique(df[[var]]))), las = 2)
}
# Vẽ biểu đồ thanh ngang hiển thị tỷ lệ người bị đột quỵ
stroke_counts <- table(df$stroke)
stroke_df <- data.frame(stroke = names(stroke_counts), count = as.numeric(stroke_counts))
ggplot(stroke_df, aes(x = reorder(stroke, count), y = count, fill = stroke)) +
geom_bar(stat = "identity") +
coord_flip() +
scale_fill_manual(values = c("0" = "#512b58", "1" = "#fe346e")) +
labs(title = "Percentage of People Having Strokes",
subtitle = "It is a highly unbalanced distribution, with only 5% having strokes",
x = "Stroke Status", y = "Count") +
theme_minimal()
install.packages("dplyr")
install.packages("gridExtra")
library(dplyr)
library(gridExtra)
# Nhóm dữ liệu theo nhóm tuổi và số lượng người bị đột quỵ
stroke_age <- df %>% filter(stroke == 1) %>% count(age_cat)
healthy_age <- df %>% filter(stroke == 0) %>% count(age_cat)
# Đọc dữ liệu
df <- read.csv("/Users/huy/Documents/doanthaytung/healthcare-dataset-stroke-data.csv")
# Chuyển đổi các biến phân loại
df <- df %>%
mutate(
gender = as.factor(gender),
ever_married = as.factor(ever_married),
work_type = as.factor(work_type),
Residence_type = as.factor(Residence_type),
smoking_status = as.factor(smoking_status),
bmi = as.numeric(bmi)
) %>%
select(-id)  # Loại bỏ cột ID
# Kiểm tra giá trị thiếu
print(colSums(is.na(df)))
# Chuyển đổi các biến phân loại thành số để tính tương quan
df_numeric <- df %>%
mutate_if(is.factor, as.numeric)
# Tính ma trận tương quan và vẽ heatmap
cor_matrix <- cor(df_numeric, use = "pairwise.complete.obs")
corrplot(cor_matrix, method = "color", col = colorRampPalette(c("blue", "white", "red"))(200),
tl.cex = 0.8, tl.col = "black", number.cex = 0.7, addCoef.col = "black")
# Xác định các biến có tương quan cao với BMI (> 0.2)
cor_with_bmi <- sort(cor_matrix["bmi", ], decreasing = TRUE)
important_features <- names(cor_with_bmi[cor_with_bmi > 0.2]) %>% setdiff("bmi")
# Xử lý dữ liệu thiếu bằng hồi quy cây quyết định
train_data <- df[!is.na(df$bmi), c(important_features, "bmi")]
missing_data <- df[is.na(df$bmi), important_features]
bmi_model <- rpart(bmi ~ ., data = train_data, method = "anova")
df$bmi[is.na(df$bmi)] <- predict(bmi_model, newdata = missing_data)
# Kiểm tra lại dữ liệu sau khi điền giá trị thiếu
print(sum(is.na(df$bmi)))
# Kiểm tra outliers và thay thế bằng Winsorization (cắt ngưỡng)
vars_to_check <- c("age", "avg_glucose_level", "bmi")
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
df[[var]][df[[var]] < lower_bound] <- lower_bound
df[[var]][df[[var]] > upper_bound] <- upper_bound
}
# Kiểm tra lại bằng boxplot
par(mfrow = c(1,3))
boxplot(df$age, main = "Age (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$avg_glucose_level, main = "Avg Glucose Level (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$bmi, main = "BMI (After Winsorization)", col = "skyblue", border = "black")
par(mfrow = c(1,1))
# Biểu đồ Histogram các biến số
numeric_vars <- names(df)[sapply(df, is.numeric)]
par(mfrow = c(ceiling(length(numeric_vars)/3),3))
for (var in numeric_vars) {
hist(df[[var]], main = paste("Histogram of", var), xlab = var, col = "green", border = "black", breaks = 20)
}
par(mfrow = c(1,1))
# Biểu đồ Barplot cho các biến phân loại
categorical_vars <- names(df)[sapply(df, is.factor)]
par(mfrow = c(ceiling(length(categorical_vars) / 3), 3))
for (var in categorical_vars) {
barplot(table(df[[var]]), main = paste("Barplot of", var), col = rainbow(length(unique(df[[var]]))), las = 2)
}
par(mfrow = c(1,1))
# Biểu đồ phân bố tỷ lệ đột quỵ
stroke_counts <- table(df$stroke)
stroke_df <- data.frame(stroke = names(stroke_counts), count = as.numeric(stroke_counts))
ggplot(stroke_df, aes(x = reorder(stroke, count), y = count, fill = stroke)) +
geom_bar(stat = "identity") +
coord_flip() +
scale_fill_manual(values = c("0" = "#512b58", "1" = "#fe346e")) +
labs(title = "Tỷ lệ người bị đột quỵ",
subtitle = "Dữ liệu bị mất cân bằng, chỉ có 5% bị đột quỵ",
x = "Trạng thái", y = "Số lượng") +
theme_minimal()
# Nhóm dữ liệu theo nhóm tuổi và số lượng người bị đột quỵ
stroke_age <- df %>% filter(stroke == 1) %>% count(age_cat)
healthy_age <- df %>% filter(stroke == 0) %>% count(age_cat)
# Biểu đồ phân bố tỷ lệ đột quỵ
stroke_counts <- table(df$stroke)
stroke_df <- data.frame(stroke = names(stroke_counts), count = as.numeric(stroke_counts))
ggplot(stroke_df, aes(x = reorder(stroke, count), y = count, fill = stroke)) +
geom_bar(stat = "identity") +
coord_flip() +
scale_fill_manual(values = c("0" = "#512b58", "1" = "#fe346e")) +
labs(title = "Tỷ lệ người bị đột quỵ",
subtitle = "Dữ liệu bị mất cân bằng, chỉ có 5% bị đột quỵ",
x = "Trạng thái", y = "Số lượng") +
theme_minimal()
# Nhóm dữ liệu theo nhóm tuổi và số lượng người bị đột quỵ
stroke_age <- df %>% filter(stroke == 1) %>% count(age_cat)
# Biểu đồ phân bố tỷ lệ đột quỵ
stroke_counts <- table(df$stroke)
# Biểu đồ phân bố tỷ lệ đột quỵ
stroke_counts <- table(df$stroke)
stroke_df <- data.frame(stroke = names(stroke_counts), count = as.numeric(stroke_counts))
ggplot(stroke_df, aes(x = reorder(stroke, count), y = count, fill = stroke)) +
geom_bar(stat = "identity") +
coord_flip() +
scale_fill_manual(values = c("0" = "#512b58", "1" = "#fe346e")) +
labs(title = "Tỷ lệ người bị đột quỵ",
subtitle = "Dữ liệu bị mất cân bằng, chỉ có 5% bị đột quỵ",
x = "Trạng thái", y = "Số lượng") +
theme_minimal()
# Cài đặt thư viện cần thiết
install.packages("corrplot")
install.packages("rpart")
install.packages("corrplot")
install.packages("rpart")
install.packages("ggplot2")
# Nạp thư viện
library(dplyr)
library(gridExtra)
library(corrplot)
library(rpart)
library(ggplot2)
# Đọc dữ liệu
df <- read.csv("/Users/huy/Documents/doanthaytung/healthcare-dataset-stroke-data.csv")
# Chuyển đổi các biến phân loại
df <- df %>%
mutate(
gender = as.factor(gender),
ever_married = as.factor(ever_married),
work_type = as.factor(work_type),
Residence_type = as.factor(Residence_type),
smoking_status = as.factor(smoking_status),
bmi = as.numeric(bmi)
) %>%
select(-id)  # Loại bỏ cột ID
# Kiểm tra giá trị thiếu
print(colSums(is.na(df)))
# Chuyển đổi các biến phân loại thành số để tính tương quan
df_numeric <- df %>%
mutate_if(is.factor, as.numeric)
# Tính ma trận tương quan và vẽ heatmap
cor_matrix <- cor(df_numeric, use = "pairwise.complete.obs")
corrplot(cor_matrix, method = "color", col = colorRampPalette(c("blue", "white", "red"))(200),
tl.cex = 0.8, tl.col = "black", number.cex = 0.7, addCoef.col = "black")
# Xác định các biến có tương quan cao với BMI (> 0.2)
cor_with_bmi <- sort(cor_matrix["bmi", ], decreasing = TRUE)
important_features <- names(cor_with_bmi[cor_with_bmi > 0.2]) %>% setdiff("bmi")
# Xử lý dữ liệu thiếu bằng hồi quy cây quyết định
train_data <- df[!is.na(df$bmi), c(important_features, "bmi")]
missing_data <- df[is.na(df$bmi), important_features]
bmi_model <- rpart(bmi ~ ., data = train_data, method = "anova")
df$bmi[is.na(df$bmi)] <- predict(bmi_model, newdata = missing_data)
# Kiểm tra lại dữ liệu sau khi điền giá trị thiếu
print(sum(is.na(df$bmi)))
# Kiểm tra outliers và thay thế bằng Winsorization (cắt ngưỡng)
vars_to_check <- c("age", "avg_glucose_level", "bmi")
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
df[[var]][df[[var]] < lower_bound] <- lower_bound
df[[var]][df[[var]] > upper_bound] <- upper_bound
}
# Kiểm tra lại bằng boxplot
par(mfrow = c(1,3))
boxplot(df$age, main = "Age (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$avg_glucose_level, main = "Avg Glucose Level (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$bmi, main = "BMI (After Winsorization)", col = "skyblue", border = "black")
par(mfrow = c(1,1))
# Biểu đồ Histogram các biến số
numeric_vars <- names(df)[sapply(df, is.numeric)]
par(mfrow = c(ceiling(length(numeric_vars)/3),3))
for (var in numeric_vars) {
hist(df[[var]], main = paste("Histogram of", var), xlab = var, col = "green", border = "black", breaks = 20)
}
par(mfrow = c(1,1))
# Biểu đồ Barplot cho các biến phân loại
categorical_vars <- names(df)[sapply(df, is.factor)]
par(mfrow = c(ceiling(length(categorical_vars) / 3), 3))
for (var in categorical_vars) {
barplot(table(df[[var]]), main = paste("Barplot of", var), col = rainbow(length(unique(df[[var]]))), las = 2)
}
par(mfrow = c(1,1))
# Biểu đồ phân bố tỷ lệ đột quỵ
stroke_counts <- table(df$stroke)
stroke_df <- data.frame(stroke = names(stroke_counts), count = as.numeric(stroke_counts))
ggplot(stroke_df, aes(x = reorder(stroke, count), y = count, fill = stroke)) +
geom_bar(stat = "identity") +
coord_flip() +
scale_fill_manual(values = c("0" = "#512b58", "1" = "#fe346e")) +
labs(title = "Tỷ lệ người bị đột quỵ",
subtitle = "Dữ liệu bị mất cân bằng, chỉ có 5% bị đột quỵ",
x = "Trạng thái", y = "Số lượng") +
theme_minimal()
df$age_cat <- cut(df$age,
breaks = c(0, 13, 18, 45, 60, 200),
labels = c("Children", "Teens", "Adults", "Mid Adults", "Elderly"),
include.lowest = TRUE)
# Nhóm dữ liệu theo nhóm tuổi và số lượng người bị đột quỵ
stroke_age <- df %>% filter(stroke == 1) %>% count(age_cat)
healthy_age <- df %>% filter(stroke == 0) %>% count(age_cat)
# Hợp nhất dữ liệu để vẽ Dumbbell Plot
dumbbell_data <- merge(healthy_age, stroke_age, by = "age_cat", all = TRUE)
colnames(dumbbell_data) <- c("age_cat", "healthy", "stroke")
# Thay NA bằng 0
dumbbell_data[is.na(dumbbell_data)] <- 0
# Biểu đồ Dumbbell
p1 <- ggplot(dumbbell_data, aes(y = age_cat)) +
geom_segment(aes(x = healthy, xend = stroke, yend = age_cat), color = "grey") +
geom_point(aes(x = healthy), size = 4, color = "#512b58", alpha = 0.8) + # Healthy (tím)
geom_point(aes(x = stroke), size = 4, color = "#fe346e", alpha = 0.8) +  # Stroke (đỏ)
labs(title = "Ảnh hưởng của tuổi tác đối với đột quỵ",
x = "Số lượng người", y = "Nhóm tuổi") +
theme_minimal()
# Biểu đồ KDE (Density Plot) so sánh phân bố tuổi
p2 <- ggplot(df, aes(x = age, fill = as.factor(stroke))) +
geom_density(alpha = 0.5) +
scale_fill_manual(values = c("#512b58", "#fe346e"), labels = c("Healthy", "Stroke")) +
labs(title = "Phân bố tuổi giữa người bị đột quỵ và người khỏe mạnh",
x = "Tuổi", y = "Mật độ", fill = "Tình trạng sức khỏe") +
theme_minimal()
# Hiển thị hai biểu đồ cùng lúc
grid.arrange(p1, p2, ncol = 2)
print(p1)
print(p2)
str(df)
df <- read.csv("/Users/huy/Documents/doanthaytung/healthcare-dataset-stroke-data.csv")
str(df)
df <- df %>%
mutate(
gender = as.factor(gender),
ever_married = as.factor(ever_married),
work_type = as.factor(work_type),
Residence_type = as.factor(Residence_type),
smoking_status = as.factor(smoking_status),
bmi = as.numeric(bmi)
) %>%
select(-id)
print(colSums(is.na(df)))
df <- read.csv("/Users/huy/Documents/doanthaytung/healthcare-dataset-stroke-data.csv")
str(df)
df <- df %>%
mutate(
gender = as.factor(gender),
ever_married = as.factor(ever_married),
work_type = as.factor(work_type),
Residence_type = as.factor(Residence_type),
smoking_status = as.factor(smoking_status),
bmi = as.numeric(bmi)
) %>%
select(-id)
print(colSums(is.na(df)))
df_numeric <- df %>%
mutate_if(is.factor, as.numeric)
# Tính ma trận tương quan và vẽ heatmap
cor_matrix <- cor(df_numeric, use = "pairwise.complete.obs")
corrplot(cor_matrix, method = "color", col = colorRampPalette(c("blue", "white", "red"))(200),
tl.cex = 0.8, tl.col = "black", number.cex = 0.7, addCoef.col = "black")
# Xác định các biến có tương quan cao với BMI (> 0.2)
cor_with_bmi <- sort(cor_matrix["bmi", ], decreasing = TRUE)
important_features <- names(cor_with_bmi[cor_with_bmi > 0.2]) %>% setdiff("bmi")
# Xử lý dữ liệu thiếu bằng hồi quy cây quyết định
train_data <- df[!is.na(df$bmi), c(important_features, "bmi")]
missing_data <- df[is.na(df$bmi), important_features]
bmi_model <- rpart(bmi ~ ., data = train_data, method = "anova")
df$bmi[is.na(df$bmi)] <- predict(bmi_model, newdata = missing_data)
# Kiểm tra lại dữ liệu sau khi điền giá trị thiếu
print(sum(is.na(df$bmi)))
par(mfrow = c(1,3))
boxplot(df$age, main = "Boxplot of Age", col = "skyblue", border = "black")
boxplot(df$avg_glucose_level, main = "Boxplot of Avg Glucose Level", col = "skyblue", border = "black")
boxplot(df$bmi, main = "Boxplot of BMI", col = "skyblue", border = "black")
vars_to_check <- c("age", "avg_glucose_level", "bmi")
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
num_outliers <- sum(df[[var]] < lower_bound | df[[var]] > upper_bound, na.rm = TRUE)
cat("Biến:", var, "- Tổng số outliers:", num_outliers, "\n")
}
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
df[[var]][df[[var]] < lower_bound] <- lower_bound
df[[var]][df[[var]] > upper_bound] <- upper_bound
}
# Kiểm tra lại bằng boxplot
par(mfrow = c(1,3))
boxplot(df$age, main = "Age (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$avg_glucose_level, main = "Avg Glucose Level (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$bmi, main = "BMI (After Winsorization)", col = "skyblue", border = "black")
par(mfrow = c(1,1))
total_rows <- nrow(df)
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
num_outliers <- sum(df[[var]] < lower_bound | df[[var]] > upper_bound, na.rm = TRUE)
percent_outliers <- (num_outliers / total_rows) * 100  # Tính phần trăm outliers
cat("Biến:", var, "- Tổng số outliers:", num_outliers,
"- Phần trăm outliers:", round(percent_outliers, 2), "%\n")
}
df <- read.csv("/Users/huy/Documents/doanthaytung/healthcare-dataset-stroke-data.csv")
str(df)
df <- df %>%
mutate(
gender = as.factor(gender),
ever_married = as.factor(ever_married),
work_type = as.factor(work_type),
Residence_type = as.factor(Residence_type),
smoking_status = as.factor(smoking_status),
bmi = as.numeric(bmi)
) %>%
select(-id)
print(colSums(is.na(df)))
df_numeric <- df %>%
mutate_if(is.factor, as.numeric)
# Tính ma trận tương quan và vẽ heatmap
cor_matrix <- cor(df_numeric, use = "pairwise.complete.obs")
corrplot(cor_matrix, method = "color", col = colorRampPalette(c("blue", "white", "red"))(200),
tl.cex = 0.8, tl.col = "black", number.cex = 0.7, addCoef.col = "black")
# Xác định các biến có tương quan cao với BMI (> 0.2)
cor_with_bmi <- sort(cor_matrix["bmi", ], decreasing = TRUE)
important_features <- names(cor_with_bmi[cor_with_bmi > 0.2]) %>% setdiff("bmi")
# Xử lý dữ liệu thiếu bằng hồi quy cây quyết định
train_data <- df[!is.na(df$bmi), c(important_features, "bmi")]
missing_data <- df[is.na(df$bmi), important_features]
bmi_model <- rpart(bmi ~ ., data = train_data, method = "anova")
df$bmi[is.na(df$bmi)] <- predict(bmi_model, newdata = missing_data)
# Kiểm tra lại dữ liệu sau khi điền giá trị thiếu
print(sum(is.na(df$bmi)))
par(mfrow = c(1,3))
boxplot(df$age, main = "Boxplot of Age", col = "skyblue", border = "black")
boxplot(df$avg_glucose_level, main = "Boxplot of Avg Glucose Level", col = "skyblue", border = "black")
boxplot(df$bmi, main = "Boxplot of BMI", col = "skyblue", border = "black")
vars_to_check <- c("age", "avg_glucose_level", "bmi")
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
num_outliers <- sum(df[[var]] < lower_bound | df[[var]] > upper_bound, na.rm = TRUE)
cat("Biến:", var, "- Tổng số outliers:", num_outliers, "\n")
}
total_rows <- nrow(df)
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
num_outliers <- sum(df[[var]] < lower_bound | df[[var]] > upper_bound, na.rm = TRUE)
percent_outliers <- (num_outliers / total_rows) * 100  # Tính phần trăm outliers
cat("Biến:", var, "- Tổng số outliers:", num_outliers,
"- Phần trăm outliers:", round(percent_outliers, 2), "%\n")
}
for (var in vars_to_check) {
Q1 <- quantile(df[[var]], 0.25, na.rm = TRUE)
Q3 <- quantile(df[[var]], 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
df[[var]][df[[var]] < lower_bound] <- lower_bound
df[[var]][df[[var]] > upper_bound] <- upper_bound
}
# Kiểm tra lại bằng boxplot
par(mfrow = c(1,3))
boxplot(df$age, main = "Age (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$avg_glucose_level, main = "Avg Glucose Level (After Winsorization)", col = "skyblue", border = "black")
boxplot(df$bmi, main = "BMI (After Winsorization)", col = "skyblue", border = "black")
par(mfrow = c(1,1))
# Biểu đồ Histogram các biến số
numeric_vars <- names(df)[sapply(df, is.numeric)]
par(mfrow = c(ceiling(length(numeric_vars)/3),3))
for (var in numeric_vars) {
hist(df[[var]], main = paste("Histogram of", var), xlab = var, col = "green", border = "black", breaks = 20)
}
par(mfrow = c(1,1))
# Biểu đồ Barplot cho các biến phân loại
categorical_vars <- names(df)[sapply(df, is.factor)]
par(mfrow = c(ceiling(length(categorical_vars) / 3), 3))
for (var in categorical_vars) {
barplot(table(df[[var]]), main = paste("Barplot of", var), col = rainbow(length(unique(df[[var]]))), las = 2)
}
par(mfrow = c(1,1))
# Biểu đồ phân bố tỷ lệ đột quỵ
stroke_counts <- table(df$stroke)
stroke_df <- data.frame(stroke = names(stroke_counts), count = as.numeric(stroke_counts))
ggplot(stroke_df, aes(x = reorder(stroke, count), y = count, fill = stroke)) +
geom_bar(stat = "identity") +
coord_flip() +
scale_fill_manual(values = c("0" = "#512b58", "1" = "#fe346e")) +
labs(title = "Tỷ lệ người bị đột quỵ",
subtitle = "Dữ liệu bị mất cân bằng, chỉ có 5% bị đột quỵ",
x = "Trạng thái", y = "Số lượng") +
theme_minimal()
df$age_cat <- cut(df$age,
breaks = c(0, 13, 18, 45, 60, 200),
labels = c("Children", "Teens", "Adults", "Mid Adults", "Elderly"),
include.lowest = TRUE)
# Nhóm dữ liệu theo nhóm tuổi và số lượng người bị đột quỵ
stroke_age <- df %>% filter(stroke == 1) %>% count(age_cat)
healthy_age <- df %>% filter(stroke == 0) %>% count(age_cat)
# Hợp nhất dữ liệu để vẽ Dumbbell Plot
dumbbell_data <- merge(healthy_age, stroke_age, by = "age_cat", all = TRUE)
colnames(dumbbell_data) <- c("age_cat", "healthy", "stroke")
# Thay NA bằng 0
dumbbell_data[is.na(dumbbell_data)] <- 0
# Biểu đồ Dumbbell
p1 <- ggplot(dumbbell_data, aes(y = age_cat)) +
geom_segment(aes(x = healthy, xend = stroke, yend = age_cat), color = "grey") +
geom_point(aes(x = healthy), size = 4, color = "#512b58", alpha = 0.8) +
geom_point(aes(x = stroke), size = 4, color = "#fe346e", alpha = 0.8) +
labs(title = "Ảnh hưởng của tuổi tác đối với đột quỵ",
x = "Số lượng người", y = "Nhóm tuổi") +
theme_minimal()
print(p1)
# Biểu đồ KDE (Density Plot) so sánh phân bố tuổi
p2 <- ggplot(df, aes(x = age, fill = as.factor(stroke))) +
geom_density(alpha = 0.5) +
scale_fill_manual(values = c("#512b58", "#fe346e"), labels = c("Healthy", "Stroke")) +
labs(title = "Phân bố tuổi giữa người bị đột quỵ và người khỏe mạnh",
x = "Tuổi", y = "Mật độ", fill = "Tình trạng sức khỏe") +
theme_minimal()
print(p2)
>>>>>>> 15b26c7d1d941b34c356f44a659f4e5911bcd13b
